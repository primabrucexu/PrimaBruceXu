# 八股文

![](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217100346.png)

---

## 1. Java

### 1.1 基础知识

#### (1) 为什么说Java是编译与解释并存

> Java源代码需要先编译成字节码（class文件），然后再通过解释器来运行

- **编译型语言**

  通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等

- **解释性语言**

  通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等

![img](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217105826.png)

- **Java 程序从源代码到运行的过程如下图所示**

  ![Java程序转变为机器代码的过程](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217105907.png)

#### (2) Java 基本类型有哪几种，各占多少位

| 基本类型 | 包装类型 | 2进制位数 | 占用空间(字节) |
| :------: | :------: | :-------: | :------------: |
|   int    | Integer  |    32     |       4        |
|   long   |   Long   |    64     |       8        |
|          |  Short   |    16     |       2        |
|   byte   |   Byte   |     8     |       1        |
|  float   |  Float   |    32     |       4        |
|  double  |  Double  |    64     |       8        |
|   char   |   Char   |    16     |       2        |
| boolean  | Boolean  |     1     |                |

#### (3) Java的泛型和擦除

- **泛型的本质**

  泛型的本质就是数据类型参数化，也就是说所操作的数据类型可以作为一个参数，从外部获取到

- **类型擦除**

  Java的泛型只存在与编译时，而在运行期间，其所含有的泛型信息将会被擦除，也就是所谓的类型擦除

  ~~~java
  public static void main(String[] args) throws Exception {
      List<Integer> list = new ArrayList<>();
      list.add(12);
      list.add("a");	// 这步操作会导致编译错误，因为Java的泛型约束在编译时还存在
      Class<? extends List> clazz = list.getClass();
      Method add = clazz.getDeclaredMethod("add", Object.class);
      add.invoke(list, "kl");	// 通过反射，可以在运行时进行操作，并且不会抛出异常。这说明了泛型信息在编译之后就被擦除了
      System.out.println(list);
  }
  ~~~

#### (4) `==` 和 `equals`

> `==` 一定 `equals`，但 `equals` 不一定 `==`

- `==`

  `==` 对于基本类型来说，比较的是值是否相同；对于引用数据类型，比较的是引用是否相同（对象的内存地址）

  > 因为 Java 只有值传递，所以，对于 `==` 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

- `equals`

  `equals`是对象专有的方法，用于比较两个对象是否相同，这里的比较逻辑可以自定义。其默认情况下则是比较两个对象的引用是否相同

  ~~~java
  // Object类的equals方法
  public boolean equals(Object obj) {
      return (this == obj);
  }
  ~~~

#### (5) `hashCode()` 和 `equals()`

- **hashCode**

  hashCode() 的作用是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。这个**哈希码的作用**是确定该对象在哈希表中的索引位置。也就是说，**hashCode() 在散列表中才有用，在其它情况下没用**

  > hashcode的用途，实际上是给堆上的对象生成一个特征码。如果没有重写hashcode的话，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
  >
  > - hashcode的实际使用
      >
      >   当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashcode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用 `equals()` 方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度

- **equals**

  equals是用来比较两个对象是否相同的

> 关于更多详细解读，请参照https://www.cnblogs.com/skywang12345/p/3324958.html

#### (6) 面向对象三大特性

- **封装**

  封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法
  ，这里只是为了举例子）

- **继承**

  对于某些具有共同点的子类，我们可以将其的共同之处抽取出来，作为父类。通过继承，以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

  ***注意点**：*

    1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
    2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
    3. 子类可以用自己的方式实现父类的方法。（以后介绍）。
    4. Java中，一个子类只能继承一个父类，但可以实现多个接口

- **多态**

  多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。

  ***特点***

    1. 对象之间具有父子关系（继承或实现）
    2. 多态调用方法的具体实现，只能在程序运行时确定
    3. 多态无法调用到子类存在而父类不存在的方法
    4. 如果子类重写了父类的方法，那么多态只能调用到子类重写后的方法

#### (7) 面向对象和面向过程的区别

- **面向过程**

  着重于解决问题时的步骤（过程），只关注解决问题的方法

- **面向对象**

  关注解决问题时对象的变化，将变化抽象成对象的某个行为

> 由于面向对象多了一个抽象的过程，所以面向对象比面向过程更容易维护、复用和扩展

#### (8) 反射

- **反射**

  通过反射，我们在运行时分析类以及执行类中的方法。通过反射，我们可以获取任意一个类的所有属性和方法并调用

#### (9) Java中形参和实参的传递方式：值传递

- 对于基础类型的参数，传递参数时传递的是变量值的副本
- 对于引用类型的参数，传递参数时传递的是对象在堆中地址的副本

#### (10) 深拷贝和浅拷贝

![img](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217150346.png)

### 1.2 集合框架

#### (1) `List`、`Set`、`Queue`、`Map` 的区别

- **List**

  存储的元素是有序的、可重复的。

  > 实现类
  >
  > - ArrayList，动态数组
  > - Vector，线程安全的动态数组
  > - LinkedList，双向链表

- **Set**

  存储的元素是无序的、不可重复的。

  > 实现类
  >
  > - HashSet
  > - LinkedHashSet
  > - TreeSet

- **Queue**

  按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。

  > 实现类
  >
  > -

- **Map**

  使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

#### (2) `ArrayList` 和 `LinkedList`

#### (3) 比较 `HashSet`、`LinkedHashSet` 和 `TreeSet` 三者

#### (4) `HashMap`、`HashTable`、以及 `ConcurrentHashMap`

### 1.3 异步编程

### 1.4 IO

---

## 2. JVM

### 2.1 内存模型

### 2.2 GC

### 2.3 类加载机制

### 2.4 常用参数及优化

---

## 3. 四大基础

### 3.1 计算机网络

#### 3.1.1 TCP

#### 3.1.2 HTTP

### 3.2 数据结构与算法

#### 3.2.1 数据结构

#### 3.2.2 算法

### 3.3 操作系统

// todo



---

## 4. 常用框架

### 4.1 Spring全家桶

### 4.2 SpringMVC

### 4.3 dubbo+zookeeper

---

## 5. 常用中间件

### 5.1 MySQL

### 5.2 Elasticsearch

### 5.3 Kafka