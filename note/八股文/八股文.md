# 八股文

![](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217100346.png)

---

## 1. Java

### 1.1 基础知识

#### (1) 为什么说Java是编译与解释并存

> Java源代码需要先编译成字节码（class文件），然后再通过解释器来运行

- **编译型语言**

  通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等

- **解释性语言**

  通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等

![img](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217105826.png)

- **Java 程序从源代码到运行的过程如下图所示**

  ![Java程序转变为机器代码的过程](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217105907.png)

#### (2) Java 基本类型有哪几种，各占多少位

| 基本类型 | 包装类型 | 2进制位数 | 占用空间(字节) |
| :------: | :------: | :-------: | :------------: |
|   int    | Integer  |    32     |       4        |
|   long   |   Long   |    64     |       8        |
|          |  Short   |    16     |       2        |
|   byte   |   Byte   |     8     |       1        |
|  float   |  Float   |    32     |       4        |
|  double  |  Double  |    64     |       8        |
|   char   |   Char   |    16     |       2        |
| boolean  | Boolean  |     1     |                |

#### (3) Java的泛型和擦除

- **泛型的本质**

  泛型的本质就是数据类型参数化，也就是说所操作的数据类型可以作为一个参数，从外部获取到

- **类型擦除**

  Java的泛型只存在与编译时，而在运行期间，其所含有的泛型信息将会被擦除，也就是所谓的类型擦除

  ~~~java
  public static void main(String[] args) throws Exception {
      List<Integer> list = new ArrayList<>();
      list.add(12);
      list.add("a");	// 这步操作会导致编译错误，因为Java的泛型约束在编译时还存在
      Class<? extends List> clazz = list.getClass();
      Method add = clazz.getDeclaredMethod("add", Object.class);
      add.invoke(list, "kl");	// 通过反射，可以在运行时进行操作，并且不会抛出异常。这说明了泛型信息在编译之后就被擦除了
      System.out.println(list);
  }
  ~~~

#### (4) `==` 和 `equals`

> `==` 一定 `equals`，但 `equals` 不一定 `==`

- `==`

  `==` 对于基本类型来说，比较的是值是否相同；对于引用数据类型，比较的是引用是否相同（对象的内存地址）

  > 因为 Java 只有值传递，所以，对于 `==` 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

- `equals`

  `equals`是对象专有的方法，用于比较两个对象是否相同，这里的比较逻辑可以自定义。其默认情况下则是比较两个对象的引用是否相同

  ~~~java
  // Object类的equals方法
  public boolean equals(Object obj) {
      return (this == obj);
  }
  ~~~

#### (5) `hashCode()` 和 `equals()`

- **hashCode**

  hashCode() 的作用是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。这个**哈希码的作用**是确定该对象在哈希表中的索引位置。也就是说，**hashCode() 在散列表中才有用，在其它情况下没用**

  > hashcode的用途，实际上是给堆上的对象生成一个特征码。如果没有重写hashcode的话，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
  >
  > - hashcode的实际使用
      >
      >   当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashcode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用 `equals()` 方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度

- **equals**

  equals是用来比较两个对象是否相同的

> 关于更多详细解读，请参照https://www.cnblogs.com/skywang12345/p/3324958.html

#### (6) 面向对象三大特性

- **封装**

  封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法
  ，这里只是为了举例子）

- **继承**

  对于某些具有共同点的子类，我们可以将其的共同之处抽取出来，作为父类。通过继承，以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

  ***注意点**：*

    1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
    2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
    3. 子类可以用自己的方式实现父类的方法。（以后介绍）。
    4. Java中，一个子类只能继承一个父类，但可以实现多个接口

- **多态**

  多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。

  ***特点***

    1. 对象之间具有父子关系（继承或实现）
    2. 多态调用方法的具体实现，只能在程序运行时确定
    3. 多态无法调用到子类存在而父类不存在的方法
    4. 如果子类重写了父类的方法，那么多态只能调用到子类重写后的方法

#### (7) 面向对象和面向过程的区别

- **面向过程**

  着重于解决问题时的步骤（过程），只关注解决问题的方法

- **面向对象**

  关注解决问题时对象的变化，将变化抽象成对象的某个行为

> 由于面向对象多了一个抽象的过程，所以面向对象比面向过程更容易维护、复用和扩展

#### (8) 反射

- **反射**

  通过反射，我们在运行时分析类以及执行类中的方法。通过反射，我们可以获取任意一个类的所有属性和方法并调用

#### (9) Java中形参和实参的传递方式：值传递

- 对于基础类型的参数，传递参数时传递的是变量值的副本
- 对于引用类型的参数，传递参数时传递的是对象在堆中地址的副本

#### (10) 深拷贝和浅拷贝

![img](https://gitee.com/primabrucexu/image/raw/main/pic/2021/12/20211217150346.png)

### 1.2 集合框架

#### (1) `List`、`Set`、`Queue`、`Map` 的区别

- **List**

  存储的元素是有序的、可重复的。

  > 实现类
  >
  > - ArrayList，动态数组
  > - Vector，线程安全的动态数组
  > - LinkedList，双向链表

- **Set**

  存储的元素是无序的、不可重复的。

  > 实现类
  >
  > - HashSet
  > - LinkedHashSet
  > - TreeSet

- **Queue**

  按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。

  > 实现类
  >
  > - PriorityQueue
  > - LinkedList
  > - ArrayDeque

- **Map**

  使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

  > 实现类
  >
  > - HashMap
  > - TreeMap

#### (2) `ArrayList` 和 `LinkedList` 的区别

- 数组和链表

  ArrayList是动态数组，LinkedList是双向链表

- 空间占用

  ArrayList会预留一定的多余空间，LinkedList则需要存放该节点的直接前驱和后继节点

- ArrayList实现了RamdomAccess，这在某些内部类的排序或者搜索时可以提高效率

  > 这个接口实际上没有任何实现，起到一个标识作用，表示该类具有随机访问的能力，主要目的是允许通用算法在应用于随机或顺序访问列表时改变其行为以提供良好的性能。

#### (3) ArrayList的扩容机制(1.5倍扩容)

~~~java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}    

private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity < 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity > MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
~~~

#### (4) 比较 `HashSet`、`LinkedHashSet` 和 `TreeSet` 三者

- HashSet为无序的集合，LinkedHashSet保留了元素添加的顺序，TreeSet是可排序的集合

#### (5) `PriorityQueue` —— 优先队列

- `PriorityQueue` 的元素出队顺序为与元素的优先级相关
- `PriorityQueue` 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据
- `PriorityQueue` 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。
- `PriorityQueue` 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
- `PriorityQueue` 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

#### (6) `HashMap`、 `HashTable`、`HashSet`

- 除了HashTable都不是线程安全的，而HashTable性能堪忧，基本不用了
- HashSet可以简单的理解为HashMap的keySet
- HashMap支持Null的K和V，但只能有一个Null的K;HashSet支持一个Null的K;HashTable都不支持

#### (7) `HashMap`和`TreeMap`

- HashMap中的元素存放是无需的
- TreeMap的元素存放是有序的，同时支持搜索

#### (8) `HashMap`原理解读

- 底层数据结构：数组(桶) + 链表/红黑树

- 如何解决哈希冲突

  拉链法。JDK1.8后，当链表长度超过8且数组长度大于64时会转换成红黑树

- **loadFactor** 负载因子

  默认0.75。太小会导致空间利用率低，太高会导致查找时间效率低。不建议修改，默认的就挺好

- **capacity** 容量

  默认为16，任何HashMap的容量总是2的n次幂（如果在创建对象时通过构造函数指定了容量，则会扩容到最近的一个2的n次幂。例如指定了17，那么容量就是32）

#### (9)`ConcurrentHashMap`解读



### 1.3 异步编程

### 1.4 IO

---

## 2. JVM

### 2.1 内存模型

### 2.2 GC

### 2.3 类加载机制

### 2.4 常用参数及优化

---

## 3. 四大基础

### 3.1 计算机网络

#### 3.1.1 TCP

#### 3.1.2 HTTP

### 3.2 数据结构与算法

#### 3.2.1 数据结构

#### 3.2.2 算法

### 3.3 操作系统

### 3.4 计算机组成

---

## 4. 常用框架

### 4.1 Spring全家桶

### 4.2 SpringMVC

### 4.3 dubbo+zookeeper

---

## 5. 常用中间件

### 5.1 MySQL

### 5.2 Elasticsearch

### 5.3 Kafka

---

## 6. 常见问题思考

### 6.1 分布式锁

#### 6.1.1 基于Redis的分布式锁

> 原理：给特定的Key赋于特定的值。如果赋值成功，则表示成功获取到分布式锁
>
>   ~~~
>   SET resource_name my_random_value NX PX 30000
>   ~~~

#### 6.1.2 基于Zookeeper的分布式锁

> 原理：zookeeper的同级节点的唯一性特性，谁先创建了这个节点，这个锁就归谁

### 6.2 缓存一致性问题

### 6.3 异地双活

### 6.4 分布式一致性协议

- 2pc、3pc、zab、bully、raft、paxos

